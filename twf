#!/usr/bin/perl -w

# twf : Turn "tree walk format" flat files into groff/dot format
#
# Copyright (C) 2020 Charles Suresh <charles.suresh@gmail.com>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

use strict;

my $rem=[];
my $stk=[];
my ($fam,$acc,$pid,$r,$match,$id,$fid,$f,$m,@c,$l,$nopush);
my $ssn=0;
print "digraph {\n";
while (<>) {
	chomp;
	next if (/^\s*\#.*/);
	s/\s*\#.*$//;
	($f,$m,@c)=split(/\|/);
	#print "$f + $m = ",join(' ', @c), "\n";
	$fid++;
	print qq(f$fid [shape=record,label="{{);
	my $x=0;
	my $find=0;
#print join(" ","stack:",map($_->[0], @$stk)), "\n";;
	if ($r=pop @$stk) {
		($match,$fam,$id)=@$r;
#print "Looking for $match $fam $id\n";
		$find=1;
	}
	$acc="";
	for my $i ($f,$m,@c) {
		$nopush=0;
		$l=$i;
		if ($nopush or $i=~s/\.$//) {
			$l=$i;
			# leaf node: story ends here
		} else {
			# more info available
			$i=~s/\s\([^\)]+\)$//;
			push @$rem, [$i,$fid,$ssn];
		}
		my $skip=0;
		if ($find and defined $match and $match eq $i) {
			$pid=$id;
			$find=0;
			$skip=1;
		} else {
			$pid=$ssn;
			#print qq{i$ssn [shape=box label="$l"];\n};
			$ssn++;
		}
		if ($x++<2) {
			#print "i$pid -> f$fid [arrowsize=0.0];\n";
			#print "i$pid -> f$fid;\n";
			print "|" if ($x==2);
			print "<i$pid>$l";
			print "}" if ($x==2);
			#$acc.="f$fid:i$pid -> f$fam;\n";
			if ($skip) {
				$acc.="f$fam:i$id -> f$fid:i$id;\n";
			}
		} else {
			if ($skip) {
				print "|{<i$pid>$l}";
				$acc.="f$fid:i$pid -> f$fam:i$id;\n";
			} else {
				print "|{<i$pid>$l}";
			}
		}
	}
	print qq(}"];\n);
	print $acc if ($acc ne '');
	die "couldn't find $match" if ($find);
	while ($r=pop @$rem) {
		push @$stk, $r;
	}
}
print "}\n";
